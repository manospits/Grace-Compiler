Package compiler;


Helpers
  empty = ;
  all = [0 .. 0xFFFF];
  sp = ' ';
  tab = '	';
  lf = 0x000a;
  cr = 0x000d;
  ff = 0x000c;
  ht = 0x0009;
  line_terminator = lf | cr | cr lf;
  backslash = '\';
  quote = ''';
  dquote = '"';
  white_space = (sp | ht | ff | line_terminator)*;
  number = ['0' ..'9'];
  letter = ['a' .. 'z'] | ['A' .. 'Z'];
  uscore = '_';
  notstar = [all - '*'];
  notstarslash = [notstar - '/'];
  c_comment = '/*' notstar* ('*'(notstarslash notstar*)?)* '*/';
  hexdigit = ['a' .. 'f'] | ['A' .. 'F'] | ['0' .. '9'];
  escapeseq = backslash 'n' | backslash 't' | backslash 'r'
              | backslash '0' | backslash backslash
              | backslash quote | backslash dquote
              | backslash 'x' hexdigit hexdigit;
  not_common_char = cr | lf | backslash | quote | dquote;
  common_char = [[[all - [cr+lf]]-[backslash + quote]]-dquote];

Tokens
  white_space = white_space;
  t_tab = tab;
  t_lf = lf;
  t_cr = cr;
  t_and      = 'and';
  t_char     = 'char';
  t_div      = 'div';
  t_do       = 'do';
  t_else     = 'else';
  t_fun      = 'fun';
  t_if       = 'if';
  t_int      = 'int';
  t_mod      = 'mod';
  t_nothing  = 'nothing';
  t_not      = 'not';
  t_or       = 'or';
  t_ref      = 'ref';
  t_return   = 'return';
  t_then     = 'then';
  t_var      = 'var';
  t_while    = 'while';
  t_id       = letter (letter | uscore | number)*;
  t_number   = (number)+;
  t_inquote  = quote common_char quote | quote escapeseq quote;
  t_indquote = dquote (common_char
                       | escapeseq )* dquote;
  t_s_plus   = '+';
  t_s_minus  = '-';
  t_s_star   = '*';
  t_s_slash  = '/';
  t_s_hash   = '#';
  t_s_equal  = '=';
  t_s_rombos = '<>';
  t_s_leq    = '<=';
  t_s_beq    = '>=';
  t_s_less   = '<';
  t_s_bigger = '>';
  t_l_par    = '(';
  t_r_par    = ')';
  t_l_ar     = '[';
  t_r_ar     = ']';
  t_l_br     = '{';
  t_r_br     = '}';
  t_comma    = ',';
  t_semi     = ';';
  t_uddot    = ':';
  t_larrow   = '<-';
  t_l_comm   = '$' [all-[cr + lf]]* line_terminator ;

Ignored Tokens
  white_space,t_lf,t_cr,t_tab,t_l_comm;

Productions

    //<program> = <func-def>
    program = func_def;

    //<func-def> = <header> (<local_def>)* <block>
    func_def =  header local_def* block;

    //<header> = "fun" <id> "("<fpar-def> (";" <fpar-def>)() ")" : <ret-type>
    header   = t_fun t_id t_l_par fpar_def header_semi_fpardef* t_r_par t_uddot ret_type;
    header_semi_fpardef = t_semi fpar_def;

    //["ref"] <id> (","<id>)* ":" <fpar-type>
    fpar_def =
        {withref}    t_id id_comma* t_uddot fpar_type |
        {withoutref} t_ref t_id id_comma* t_uddot fpar_type;
    id_comma = t_comma t_id;

    //<data-type> = "int" | "char"
    data_type =
            {int} t_int |
            {char} t_char;

    //<type> = <data-type> ("[" <int-const> "]")*
    type = data_type array_dec*;
    array_dec = t_l_ar t_number t_r_ar;

    //<ret-type> <data-type> | "nothing"
    ret_type =
            data_type |
            {nothing} t_nothing;

    //<fpar-type> = <data-type> ["[" "]"] ( "[" <int-const> "]")*
    fpar_type_t_ar_empty = t_l_ar t_r_ar;
    fpar_type_t_ar = t_l_ar t_number t_r_ar;
    fpar_type =
        {fpar_type_without_empty}    data_type fpar_type_t_ar* |
        {fpar_type_with_empty}   data_type fpar_type_t_ar_empty fpar_type_t_ar*;

    //<local-def> = <func-def> | <func-decl> | <var-def>
    local_def =
        {func_def}   func_def  |
        {func_decl}  func_decl |
        {var_def}    var_def;

    //<var-def> = "var" <id> (",",<id>)* ":" <type> ";"
    var_def   = t_var t_id id_comma* t_uddot type t_semi;

    //<func-decl> = <header> ";"
    func_decl = header t_semi;

    //<block> = "{" (<stmt>)* "}"
    block = t_l_br t_r_br;
