Package compiler;


Helpers
  empty = ;
  all = [0 .. 0xFFFF];
  sp = ' ';
  tab = '	';
  lf = 0x000a;
  cr = 0x000d;
  ff = 0x000c;
  ht = 0x0009;
  line_terminator = lf | cr | cr lf;
  backslash = '\';
  quote = ''';
  dquote = '"';
  white_space = (sp | ht | ff | line_terminator)*;
  number = ['0' ..'9'];
  letter = ['a' .. 'z'] | ['A' .. 'Z'];
  uscore = '_';
  notstar = [all - '*'];
  notstarslash = [notstar - '/'];
  hexdigit = ['a' .. 'f'] | ['A' .. 'F'] | ['0' .. '9'];
  escapeseq = backslash 'n' | backslash 't' | backslash 'r'
              | backslash '0' | backslash backslash
              | backslash quote | backslash dquote
              | backslash 'x' hexdigit hexdigit;
  not_common_char = cr | lf | backslash | quote | dquote;
  common_char = [[[all - [cr+lf]]-[backslash + quote]]-dquote];
  not_dollar = [all-'$'];
  not_dollar_line_terminator = [not_dollar-[cr+lf]];

Tokens
  white_space = white_space;
  t_tab      = tab;
  t_lf       = lf;
  t_cr       = cr;
  t_and      = 'and';
  t_char     = 'char';
  t_div      = 'div';
  t_do       = 'do';
  t_else     = 'else';
  t_fun      = 'fun';
  t_if       = 'if';
  t_int      = 'int';
  t_mod      = 'mod';
  t_nothing  = 'nothing';
  t_not      = 'not';
  t_or       = 'or';
  t_ref      = 'ref';
  t_return   = 'return';
  t_then     = 'then';
  t_var      = 'var';
  t_while    = 'while';
  t_id       = letter (letter | uscore | number)*;
  t_number   = (number)+;
  t_char_con = quote common_char quote | quote escapeseq quote;
  t_string  = dquote (common_char
                       | escapeseq )* dquote;
  t_s_plus   = '+';
  t_s_minus  = '-';
  t_s_star   = '*';
  t_s_slash  = '/';
  t_s_hash   = '#';
  t_s_equal  = '=';
  t_s_rombos = '<>';
  t_s_leq    = '<=';
  t_s_beq    = '>=';
  t_s_less   = '<';
  t_s_bigger = '>';
  t_l_par    = '(';
  t_r_par    = ')';
  t_l_ar     = '[';
  t_r_ar     = ']';
  t_l_br     = '{';
  t_r_br     = '}';
  t_comma    = ',';
  t_semi     = ';';
  t_uddot    = ':';
  t_larrow   = '<-';
  t_l_comm   = '$' (not_dollar_line_terminator+ [all-[cr + lf]]*)* line_terminator ;
  t_ml_comm  = '$$' not_dollar* '$' ( not_dollar not_dollar* '$' )* '$';

Ignored Tokens
  white_space,t_lf,t_cr,t_tab,t_ml_comm,t_l_comm;

Productions

    //<program> = <func-def>
    program = func_def;

    //<func-def> = <header> (<local_def>)* <block>
    func_def =  header local_def* block;

    //<header> = "fun" <id> "("<fpar-def> (";" <fpar-def>)() ")" : <ret-type>
    header   = t_fun t_id t_l_par header_members? t_r_par t_uddot ret_type;
    header_semi_fpardef = t_semi fpar_def;
    header_members = fpar_def header_semi_fpardef*;

    //<fpar-def> = ["ref"] <id> (","<id>)* ":" <fpar-type>
    fpar_def = t_ref? t_id id_comma* t_uddot fpar_type;
    id_comma = t_comma t_id;

    //<data-type> = "int" | "char"
    data_type =
            {int} t_int |
            {char} t_char;

    //<type> = <data-type> ("[" <int-const> "]")*
    type = data_type array_dec*;
    array_dec = t_l_ar t_number t_r_ar;

    //<ret-type> <data-type> | "nothing"
    ret_type =
            {ret_data_type} data_type |
            {nothing} t_nothing;

    //<fpar-type> = <data-type> ["[" "]"] ( "[" <int-const> "]")*
    fpar_type = data_type fpar_type_t_ar_empty? fpar_type_t_ar* ;
    fpar_type_t_ar_empty = t_l_ar t_r_ar;
    fpar_type_t_ar = t_l_ar t_number t_r_ar;

    //<local-def> = <func-def> | <func-decl> | <var-def>
    local_def =
        {func_def}   func_def  |
        {func_decl}  func_decl |
        {var_def}    var_def;

    //<var-def> = "var" <id> (",",<id>)* ":" <type> ";"
    var_def   = t_var t_id id_comma* t_uddot type t_semi;

    //<func-decl> = <header> ";"
    func_decl = header t_semi;

    //<stmt> = ";" | <l-value> "<-" <expr> ";" | <block> | <func_call> ";"
    //       | "if" <cond> "then" <stmt> [ "else" <stmt> ]
    //       | "while" <cond> "do" <stmt> | return [<expr>] ";"
    stmt =
            {stmt_semi} t_semi                         |
            {stmt_lvalue} l_value t_larrow expr t_semi |
            {stmt_block} block                         |
            {stmt_func_call} func_call t_semi          |
            {stmt_if} if                               |
            {stmt_return} t_return expr? t_semi        |
            {stmt_while} while;

    while = t_while cond t_do stmt;
    while_else = t_while cond t_do stmt_else;

    if = if_header if_trail;
    if_header = t_if cond t_then;
    if_trail =
            {without_else} stmt |
            {with_else} stmt_else t_else stmt;

    stmt_else =
            {stmt_else_semi} t_semi                         |
            {stmt_else_lvalue} l_value t_larrow expr t_semi |
            {stmt_else_block} block                         |
            {stmt_else_func_call} func_call t_semi          |
            {stmt_else_return} t_return expr? t_semi        |
            {stmt_else_if} if_else                          |
            {stmt_while} while_else;

    if_else = if_header [then]:stmt_else t_else [else]:stmt_else;


    //<block> = "{" (<stmt>)* "}"
    block = t_l_br stmt* t_r_br;

    //<func-call> = <id> "(" [ <expr> ( "," <expr> ) *] ")"
    func_call = t_id t_l_par func_call_optional? t_r_par;
    func_call_optional = expr comma_expr*;
    comma_expr= t_comma expr;

    //<l-value> = <id> | <string-literal> | <l-value> "[" <expr> "]"
    l_value =
        {l_value_id}       t_id     |
        {l_value_string}   t_string |
        {l_value_array}    l_value  t_l_ar expr t_r_ar;

    //<expr> = <int-const> | <char-const> | <l-value> | <func-call> | "(" <expr> ")"
    //       | ( "+" | "-" ) <expr> ("+" | "-" | "*" | "div" | "mod" ) <expr>
    expr =
            {plus}  expr t_s_plus  expr_m|
            {minus} expr t_s_minus expr_m|
            {multdivmod} expr_m;

    expr_m =
            {post_mult} expr_m t_s_star expr_ipm|
            {post_div}  expr_m t_div    expr_ipm|
            {post_mod}  expr_m t_mod    expr_ipm|
            {infixplusminus}       expr_ipm;

    expr_ipm =
            {inplus}  t_s_plus  expr_bottom|
            {inminus} t_s_minus expr_bottom|
            {bottom} expr_bottom;

    expr_bottom =
            {const} t_number           |
            {char} t_char_con          |
            {func_call_type} func_call |
            {l_value_type} l_value     |
            {parebthesis} t_l_par expr t_r_par ;

    //cond = "(" <cond> ")" | "not" <cond> | <cond> ("and" | "or" ) <cond>
    //     | <expr> ("=" | "#" | "<" | ">" "<=" | ">=") <expr>

    cond =
        {cond_or}    cond t_or condand|
        {cond_and}   condand;

    condand =
        {condand_and} condand t_and condnot|
        {cond_not}    condnot;

    condnot =
        {condnot_not} t_not cond_bottom|
        {cond_bottom} cond_bottom;

    cond_bottom =
        {cond_equal}  [left]:expr t_s_equal  [right]:expr |
        {cond_hash}   [left]:expr t_s_hash   [right]:expr |
        {cond_bigger} [left]:expr t_s_bigger [right]:expr |
        {cond_less}   [left]:expr t_s_less   [right]:expr |
        {cond_leq}    [left]:expr t_s_leq    [right]:expr |
        {cond_beq}    [left]:expr t_s_beq    [right]:expr |
        {cond_par}    [left]:t_l_par cond t_r_par;



